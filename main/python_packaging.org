:PROPERTIES:
:ID:       bb57f65e-58f4-45de-9620-901dc998f6d6
:END:
#+TITLE: Python Packaging
#+DATE: [2022-04-27 Wed 07:38]
#+FILETAGS: :python:programming:packaging:

There are several options for packaging your code in Python, this document focuses on [[https://setuptools.pypa.io/en/latest/index.html][Setuptools]].

* Package Structure

You should place your code within a Git version controlled directory for your project. It is then normal to place all
files in an organised hierarchy with a sub-directory of the same name for Python code, tests under ~tests~

#+BEGIN_SRC bash eval: no
  .
  ├── ./build
  ├── ./dist
  ├── ./
  ├── ./tcx2gpx
  └── ./tests
      ├── ./tests/resources
      └── ./tests/tcx2gpx
#+END_SRC

* Entry Points

It can be useful to provide an entry point to your package so that users can simply type a single command after
installing the package (typically under a virtual environment) to be able to run it from the command line. An exposition
of this approach can be read [[https://amir.rachum.com/blog/2017/07/28/python-entry-points/][here]] and the documentation on how to do this with setuptools is [[https://setuptools.pypa.io/en/latest/userguide/entry_point.html][here]]. Add something similar
to the following to your ~setup.cfg~

#+begin_src conf :eval no
  [options.entry_points]
  console_scripts =
      find_pg = pgfinder:find_pg
#+end_src

With the function you wish to run defined in ~__init__.py~ and a hook defined in ~__main__.py~.

* Resources

Including resources such as default parameters is possible. A useful thread on StackOverflow is [[https://stackoverflow.com/questions/6028000/how-to-read-a-static-file-from-inside-a-python-package][here]] (most useful
answers I found were [[https://stackoverflow.com/a/58941536][this]] which includes a link to an [[https://github.com/wimglenn/resources-example][example repository]] comparing the different approaches and [[https://stackoverflow.com/a/51724506][this
exposition of pkgutil]]).

The examples don't quite fit my use case as I typically load parameters and configuration from YAML files, to do this I
placed the files under ~<package>/config/parameters.yaml~ and then in ~__init__.py~ have the following...

#+begin_src python :eval no
  import yaml
  from pkgutil import get_data

  PARAMETERS_FILE = "config/parameters.yaml"
  PARAMETERS = get_data(__package__, PARAMETERS_FILE)
  PARAMETERS = yaml.safe_load(PARAMETERS)
#+end_src

~PARAMETERS~ is now a dictionary that contains the contents of ~config/parameters.yaml~.

* Setup

Traditionally configuration of meta-data such as author, code repository and license was made via ~setup.py~ but under
the current version of Setuptools that is obsolete. Instead it is essential to have a ~pyproject.toml~ file in the top
level of your directory with a bare minimum of...

#+begin_src conf
  [build-system]
  requires = ["setuptools"]
  build-backend = "setuptools.build_meta"
#+end_src

You can then continue to use this file for additional configuration options or use ~setup.cfg~ or ~setup.py~ (although
the later is discouraged). A sample ~setup.cfg~ is shown below, some key fields to note are the
~long_description_content_type = text/markdown~ which will ensure that if you use Markdown for the ~README.md~ it will
be correctly rendered.

#+begin_src conf :eval no
  [metadata]
  name = pgfinder
  version = 0.0.1
  description =
  long_description = file: README.md
  long_description_content_type = text/markdown
  url = https://github.com/Mesnage-Org/pgfinder
  author = pgfinder Team
  license = GNU Lesser GPLv3
  project_urls =
    Bug Tracker = https://github.com/Mesnage-Org/pgfinder/issues
    Documentation = https://mesnage-org.github.io/pgfinder/


  [options]
  python_requires = >=3.7

  zip_safe = False

  install_requires =
    matplotlib
    numpy
    pandas
    ruamel.yaml
    pysqlite3
    pyyaml

  packages = find:

  [options.extras_require]
  tests =
    pytest>=7.0
    pytest-cov
    pytest-mpl

  docs =
    Sphinx<5.0
    sphinx_rtd_theme
    myst_parser
    sphinx_markdown_tables
    pydata_sphinx_theme
    sphinxcontrib-mermaid

  [options.packages.find]
  exclude = tests*

  [coverage:run]
  omit =
    *conftest.py
    *tests*
    **/__init__*
#+end_src

** Package Data

Sometimes you will want to include additional files in your package such as a default YAML configuration file that can
be loaded.

THis is done using the ~[options.package_data]~ section of ~setup.cfg~ and placing your files under the source of your
package (i.e. the sub-directory that contains the Python code).

#+begin_src conf :eval no
  [options.package_data]
  * = *.yaml
#+end_src

To load the files of a package you should use then [[https://docs.python.org/3.8/library/importlib.html][~importlib.resources~ module]]

Specific files can be included and excluded on a per package basis see [[https://jwodder.github.io/kbits/posts/pypkg-data/][examples]] and the [[https://setuptools.pypa.io/en/latest/userguide/datafiles.html][official documentation]].

* Publishing to PyPi

[[https://pypi.org][PyPi]] is the Python Package Index that provides a central repository for installing packages using [[https://pip.pypa.io/en/stable/][~pip~]] (although ~pip~
can be configured to work with other such servers such as internal private ones).

To facilitate publishing packages to PyPi there is [[https://test.pypi.org/][TestPyPI]] which is a mirror where you can test deployment. Create
accounts on both the main PyPi and TestPyPi servers.

** Generate Distribution Archive

In your package you should create an archive of your package with the latest versions of ~setuptools~ and ~wheel~. To do
this in your virtual environment run the following. The documentation for how to do this is at [[https://setuptools.pypa.io/en/latest/setuptools.html][Building and Distributing
Packages with Setuptools]].

It is not essential to have a ~setup.py~ which is being deprecated if you are using the newer recommended ~setup.cfg~ /
~pyproject.toml~  combination to configure your package as ~setuptools~ will create a dummy file with the required
contents for you providing you have the following in ~pyproject.toml~.


#+begin_src :eval no
  [build-system]
  requires = [
    "setuptools >= 40.9.0",
    "wheel",
  ]
  build-backend = "setuptools.build_meta"
#+end_src

The package can now be built locally with...

#+begin_src bash :eval no
  python -m pip install --upgrade setuptools wheel
  python -m build
#+end_src

* Publishing on [[https://test.pypi.org/][TestPyPI]]

Before pushing the package to the main PyPi server it is prudent to test things out on  [[https://test.pypi.org/][TestPyPI]] first. You must first
generate an API Token from your account settings page. It needs a name and the scope should be `Entire account (all
projects)`. This token will be shown once so do *not* navigate away from the page until you have copied it.

pypi-AgENdGVzdC5weXBpLm9yZwIkNzhiNzc0ZjAtNmNjZS00ZWU4LTk2OWItZjVjZDFhYTFkYzBjAAIleyJwZXJtaXNzaW9ucyI6ICJ1c2VyIiwgInZlcnNpb24iOiAxfQAABiAMm9-iuKcpGQsydQBXm7G_doS5wn6CJmnCDtYtaLZRYg

You use [[https://twine.readthedocs.io/en/latest/][twine]] to upload the package and should create a ~.pypirc~ file in the root of the packages directory that
contains your API key and the username ~__token__~

#+begin_src conf :eval no
  [testpypi]
    username = __token__
    password = pypi-AgENdGVzdC5weXBpLm9yZwIkNzhiNzc0ZjAtNmNjZS00ZWU4LTk2OWItZjVjZDFhYTFkYzBjAAIleyJwZXJtaXNzaW9ucyI6ICJ1c2VyIiwgInZlcnNpb24iOiAxfQAABiAMm9-iuKcpGQsydQBXm7G_doS5wn6CJmnCDtYtaLZRYg
#+end_src

Once this is in place you are ready to use ~twine~ to upload the package using the configuration file you have just
created.

#+begin_src bash :eval no
  twine upload --config-file ./.pypirc --repository testpypi dist/*
#+end_src

** Testing the Package

After having uploaded your package to the TestPyPI server you should create a clean virtual environment and try
installing the package from where you have just uploaded it. You can do this using ~pip~ and the ~--index-url~ and
~--extra-index-url~, the former installs your package from TestPyPI, the later installs dependencies from PyPI.

#+begin_src bash :eval no
  pip install https://test.pypi.org/simple/ --extra-index-url https://pypi.org/simple/ your-package
#+end_src

Once installed you can try running the code, scripts or notebooks associated with the package as you would normally.

* Versioning and Automating Releases

Typically the version is defined in the ~__version__~ value or as a value in ~setup.cfg~ or ~pyproject.toml~ but this
has some downsides in that you have to remember to update the string manually when you are ready for a release and it
doesn't tie in with using tags in Git to tag versions of your commits.

** Versioneer

Enter [[https://github.com/python-versioneer/python-versioneer][versioneer]] which specifically sets out to handle this very problem.

#+BEGIN_QUOTE
This is a tool for managing a recorded version number in distutils/setuptools-based python projects. The goal is to
remove the tedious and error-prone "update the embedded version string" step from your release process. Making a new
release should be as easy as recording a new tag in your version-control system, and maybe making new tarballs.
#+END_QUOTE

The [[https://github.com/python-versioneer/python-versioneer/blob/master/INSTALL.md][installation instructions]] are concise and clear and should be easy to follow. Configuration is through a section in
~setup.cfg~ and typically the required style is ~pep440~ but it is worth being aware that ~versioneer~ produces versions
that indicates if you're branch ~HEAD~ is ahead of the last ~git tag~ that was applied and that these are not compliant
with [[https://peps.python.org/pep-0440/][PEP440]]. The side effect of this is that you will not be able to upload your package to [[https://pypi.org][PyPI]] either manually or via
a GitHub Action (more on this below). If you want to force PEP40 compliance then you should use ~style = pep440-pre~
which whilst indicating information about how far ahead of the last tag the current commit is still produces valid
PEP440 versions.

*** Configure ~setup.cfg~/~pyproject.toml~

You need to add configuration to ~setup.cfg~ or ~pyproject.toml~. The ~versionfile_source~ /~versionfile_build~
directories are typically the package name if you have followed the structure suggested in the [previous
article](python-packages-3), but see the [[https://github.com/python-versioneer/python-versioneer/blob/master/INSTALL.md][versioneer documentation]] for further details. If your [[https://git-scm.com/book/en/v2/Git-Basics-Tagging][git tags]] contain a prefix
then you should include it. If your package unpacks to a specific directory then include it under ~parentdir_prefix~.

#+begin_src
[versioneer]
VCS = git
style = pep440
versionfile_source = <package_name>/_version.py
versionfile_build = <package_name>/_version.py
tag_prefix = v
parentdir_prefix =
#+end_src

#+begin_src
[tool.versioneer]
VCS = "git"
style = "pep440"
versionfile_source = "<package_name>/_version.py"
versionfile_build = "<package_name>/_version.py"
tag_prefix = ""
parentdir_prefix = ""
#+end_src

*** Install

You can now install ~versioneer~ into your package, there are two options ~--vendor~ or ~--no-vendor~ to choose
between. Typically I would opt for ~--vendor~ as the non-vendored mode is experimental and requires additional
configuration options in ~pyproject.toml~ (see [[https://github.com/python-versioneer/python-versioneer/blob/master/INSTALL.md][versioneer documentation]] for further details).


#+begin_src bash :eval no
versioneer install --vendor
#+end_src

This will install files and stage them automatically, remember to stage your changes to ~setup.cfg~ / ~pyproject.toml~
before committing.

*** Build

When it comes to building I found that the current version of [[https://pypa-build.readthedocs.io/en/latest/][build]] (0.8.0 as of writing) by default creates a virtual
environment to build the package under and this resulted in an error about ~versioneer~ not being installed (see [[https://github.com/python-versioneer/python-versioneer/issues/192][related
issue #192]], although I was using the default ~style = pep440~). My solution was to try using the ~--no-isolation~ (~-n~)
flag to build so that a virtual environment was not used.

#+BEGIN_SRC bash :eval no
  python -m build --no-isolation
  * Getting dependencies for sdist...

#+END_SRC

You should find your package builds and the resulting ~.tar.gz~ and ~.whl~ files include the version calculated by
~versioneer~ and that it will be based on the most recent tag. If your branch is ahead of the last tag then it will
include information on how far ahead it is.

*** Excluding ~<package>/_version.py~

You may wish to exclude the ~<package>/_version.py~ from some of your linting if for example you are using
[[https://ns-rse.github.io/posts/pre-commit][pre-commit]].  At the command line you can exclude a file from being included in ~flake8~ analyses with
~--exclude=<patterns>~ and so at the command line you would.

<p class="codeblock-label"></p>
#+CAPTION: ~flake8~ excluding ~_version.py~
#+BEGIN_SRC bash :eval no
flake8 --exclude=<package>/_version.py
#+END_SRC

If you are using ~flake8~ in ~pre-commit~ then you can add and ~args~ entry to the ~.pre-commit-config.yaml~
configuration file as shown below.

#+CAPTION: ~.pre-commit-config.yaml~ excluding ~_version.py~
#+BEGIN_SRC yaml :eval no
  - repo: https://gitlab.com/pycqa/flake8.git
    rev: 3.9.2
    hooks:
      - id: flake8
        args: ["--exclude=topostats/_version.py"]
        additional_dependencies: [flake8-print]
        types: [python]
#+END_SRC

** GitHub Action

The GitHub Action [[https://github.com/pypa/gh-action-pypi-publish][gh-action-pypi-publish]] is available to automate publishing to PyPI. You will have to [[https://pypi.org/help/#apitoken][generate a PYPI
token]] (and similarly one for [[https://test.pypi.org][test PyPI]]) and store these under /Settings > Secrets > Actions/ with the names
~PYPI_API_TOKEN~ and ~TEST_PYPI_API_TOKEN~ respectively.  You can then include the following GitHub Action under
~.github/workflow/pypi.yaml~.

#+BEGIN_SRC yaml :eval no
name: Publish package to PyPi

on:
  push:
    branches:
      - master
      # - test/branch    # Uncomment and replace with the branch you are testing on
jobs:
  build-release:
    runs-on: ubuntu-latest
    name: Publish package to PyPi
    steps:
      - uses: actions/checkout@v3
        with:
          fetch-depth: 0
      - name: Setup Python
        uses: actions/setup-python@v3
        with:
          python-version: 3.9
      - name: Installing the package
        run: |
          pip3 install versioneer
          pip3 install .
          pip3 install .[pypi]
      - name: Build package
        run: |
          python -m build --no-isolation
      - name: Publish package to Test PyPI
        uses: pypa/gh-action-pypi-publish@release/v1
        with:
          user: __token__
          repository_url: https://test.pypi.org/legacy/
          password: ${{ secrets.TEST_PYPI_API_TOKEN }}
      - name: Publish package to PyPI
        if: github.event_name == 'push' && startsWith(github.ref, 'refs/tags')
        uses: pypa/gh-action-pypi-publish@release/v1
        with:
          user: __token__
          password: ${{ secrets.PYPI_API_TOKEN }}
#+END_SRC

** Step-by-step

1. ~pip install versioneer~
2. Modify ~pyproject.toml~ or ~setup.cfg~ (I use the later). It is /vital/ that the ~tag_prefix~ is correct.
   #+BEGIN_SRC python :eval no
   [versioneer]
   VCS = git
   style = pep440
   versionfile_source = clarity/_version.py
   versionfile_build = clarity/_version.py
   tag_prefix = v
   parentdir_prefix =
   #+END_SRC
3. If using non-vendored mode further modify ~pyproject.toml~
4. Add ~import versioneer~ and additional lines to obtain version to ~setup.py~
   #+BEGIN_SRC python :eval no
     """Package setup"""
     from setuptools import setup
     import versioneer

     setup(
         version=versioneer.get_version(),
         cmdclass=versioneer.get_cmdclass(),
     )
   #+END_SRC
5. Run ~versioneer install --[no-]vendor~ (I have used ~--no-vendor~ so far).
6. Add ~versioneer~ to the ~[pypi]~ requirements section of ~setup.cfg~
   #+BEGIN_SRC python :eval no
   [options.extras_require]
   pypi =
     build
     versioneer
   #+END_SRC
7. ~pip install .[pypi]~
8. Add the ~pypi.yaml~ to ~\~/.github/workflows/~ directory.
   #+BEGIN_SRC yaml :eval no
     name: Publish package to PyPi

on:
  push:
    branches:
      - master

jobs:
  build-release:
    runs-on: ubuntu-latest
    name: Publish package to PyPi
    steps:
      - uses: actions/checkout@v3
        with:
          fetch-depth: 0
      - name: Setup Python
        uses: actions/setup-python@v3
        with:
          python-version: 3.9
      - name: Installing the package
        run: |
          pip3 install .
          pip3 install .[pypi]
      - name: Build package
        run: |
          python -m build --no-isolation
      - name: Publish package to Test PyPI
        if: github.event_name == 'push'
        uses: pypa/gh-action-pypi-publish@release/v1
        with:
          user: __token__
          password: ${{ secrets.TEST_PYPI_API_TOKEN }}
      - name: Publish package to PyPI
        if: github.event_name == 'push' && startsWith(github.ref, 'refs/tags')
        uses: pypa/gh-action-pypi-publish@release/v1
        with:
          user: __token__
          password: ${{ secrets.PYPI_API_TOKEN }}

   #+END_SRC
9. Add new repository secrets for [[https://pypi.org/][PYPI_API_TOKEN]] and [[https://test.pypi.org][TEST_PYPI_API_TOKEN]] under /Settings > Secrets > Actions/ you have
   to generate the tokens on both PyPI and Test PyPI.
* PDM

New kid on the block is [[https://pdm.fming.dev/latest/][PDM]] (Python package and Dependency Manager) which handles all stages of setting up and creating
a package and managing its dependencies.

* Links

+ [[https://packaging.python.org/en/latest/tutorials/packaging-projects/][Packaging Python Projects]]
+ [[https://setuptools.pypa.io/en/latest/setuptools.html][Building and Distributing Packages with Setuptools]]
+ [[https://github.com/wimglenn/resources-example][Packaging Data files in a Python Distribution]]
+ [[https://pdm.fming.dev/latest/][PDM - Python package and Dependency Manager]]
