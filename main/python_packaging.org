:PROPERTIES:
:ID:       bb57f65e-58f4-45de-9620-901dc998f6d6
:mtime:    20230103103312 20221228113913 20230103103309
:ctime:    20221228113913 20230103103309
:END:
#+TITLE: Python Packaging
#+DATE: [2022-04-27 Wed 07:38]
#+FILETAGS: :python:programming:packaging:pip:

This page describes steps in creating a [[id:5b5d1562-ecb4-4199-b530-e7993723e112][Python]] package. If you are looking for information on installing packages this
is done using [[id:47543a76-a873-4c07-b30d-926f50b31fca][Python PIP]].

[[id:5b5d1562-ecb4-4199-b530-e7993723e112][Python]] packaging is it seems in a constant state of flux. There is the official [[https://packaging.python.org/en/latest/][Python Packaging User Guide]] from the
[[https://www.pypa.io/en/latest/][Python Packaging Authority]] which is probably the best resource to read but things change, and often quickly. This
document focuses on [[https://setuptools.pypa.io/en/latest/index.html][Setuptools]] which works with Python >= 3.7, but you may wish to consider other packages such as
[[id:8aed2c14-86e7-4b0e-bfe6-e783831bfca2][Poetry]] or [[id:37748065-f956-4d0c-9301-c4d51439b1b4][PDM]] which offer some advantages but with additional learning.

* Package Structure

You should place your code within a Git version controlled directory for your project. It is then normal to place all
files in an organised hierarchy with a sub-directory of the same name for Python code, tests under ~tests~

#+BEGIN_SRC sh eval: no
  .
  ├── ./build
  ├── ./dist
  ├── ./
  ├── ./topostats
  ├── ./topostats/__init__.py
  ├── ./topostats/filters.py
  ├── ./topostats/grains.py
  └── ./tests
      ├── ./tests/conftest.py
      ├── ./tests/resources
      └── ./tests/tracing
#+END_SRC

** \__init\__.py

In older versions of Python (<3.3) a ~__init__.py~ was required in every directory and sub-directory that was to be a
module/sub-module. In more recent versions of Python (>\=3.3) they are not essential though as Python uses [[https://docs.python.org/3/reference/import.html#namespace-packages][namespace
packages]]. But in most cases its simpler to include such a file in the top level of your directory.  ~__init__.py~ files
can be completely empty or they can contain code that is used throughout your package, such as setting up a logger or
setting the package version.

#+CAPTION: Example ~__init__.py~ that sets up logging and sets the ~__version__~
#+BEGIN_SRC python :eval no
  """Topostats"""
  from .logs.logs import setup_logger
  from . import _version

  LOGGER = setup_logger()

  __version__ = _version.get_versions()["version"]
#+END_SRC



* Configuration

** setup.py

This is the traditional method of configuring a package in conjunction with a ~requirements.txt~, but has been
deprecated in favour of ~setup.cfg~ and/or ~pyproject.toml~. The remainder of this document does not therefore describe
detailed usage of this approach (although it is required by [[#versioneer][Versioneer]]).

#+CAPTION: ~setup.py~ from [[https://github.com/AFM-SPM/TopoStats/blob/main/pyproject.toml][TopoStats]].
#+begin_src conf
"""Setup package for building"""
import setuptools
import sys
import versioneer

sys.path.insert(0, ".")
setuptools.setup(
    version=versioneer.get_version(),
    cmdclass=versioneer.get_cmdclass(),
)

#+end_src

** pyproject.toml

Setuptools is shifting towards using ~pyproject.toml~ and whilst it is still under development although its already
highly functional. Its written in [[https://toml.io/en/][Tom's Obvious Minimal Language]] and isn't too dissimilar in structure to ~setup.cfg~.


A bare-bones ~pyproject.toml~ file should reside in the top level of your directory with the following...

*** Build System
#+CAPTION: ~build-system~ section of ~pyproject.toml~ from [[https://github.com/AFM-SPM/TopoStats/blob/main/pyproject.toml][TopoStats]].
#+begin_src conf
  [build-system]
  requires = ["setuptools"]
  build-backend = "setuptools.build_meta"
#+end_src

Traditionally configuration of meta-data such as author, code repository and license was made via ~setup.py~ but you can
either specify some (or most) of this in ~pyproject.toml~ or a concurrent ~setup.cfg~.

*** Pytest Options

#+CAPTION: ~tool.versioneer~ section of ~pyproject.toml~ from [[https://github.com/AFM-SPM/TopoStats/blob/main/pyproject.toml][TopoStats]].
#+begin_src conf
[tool.pytest.ini_options]
minversion = "7.0"
addopts = "--cov --mpl"
testpaths = [
    "tests",
]
filterwarnings = [
    "ignore::DeprecationWarning",
    "ignore::UserWarning"
]

#+end_src

*** Black Options

#+CAPTION: ~tool.black~ section of ~pyproject.toml~ from [[https://github.com/AFM-SPM/TopoStats/blob/main/pyproject.toml][TopoStats]].
#+begin_src conf
[tool.black]
line-length = 120
target-version = ['py38']
exclude = '''

(
  /(
      \.eggs         # exclude a few common directories in the
    | \.git          # root of the project
    | \.venv
  )/
)
'''

#+end_src


*** Versioneer Options

#+CAPTION: ~build-system~ section of ~pyproject.toml~ from [[https://github.com/AFM-SPM/TopoStats/blob/main/pyproject.toml][TopoStats]].
#+begin_src conf
[tool.versioneer]
VCS = "git"
style = "pep440"
versionfile_source = "topostats/_version.py"
versionfile_build = "topostats/_version.py"
tag_prefix = "v"
parentdir_prefix = ""
#+end_src

** setup.cfg

A sample ~setup.cfg~ is shown below (its from the [[github.com/AFM-SPM/TopoStats/][TopoStats]] project).


*** Metadata

Metadata is important as it provides key information about your package and is used by different services such as PyPI
or for adding badges to your project. If you write your ~README.md~ in [[id:0c371287-128d-4e46-8128-b2d4f5fc604c][Markdown]] then be sure to include the fields
~long_description_content_type = text/markdown~ which will ensure that it is correctly rendered on PyPI.

#+CAPTION: Sample ~metadata~ section of ~setup.cfg~ from [[https://github.com/AFM-SPM/TopoStats/blob/main/setup.cfg][TopoStats]].
#+BEGIN_SRC conf :eval no
[metadata]
name = topostats
description = Automated Analysis for Atomic Force Microscopy Images of Biomolecules
long_description = file: README.md
long-description-content-type: text/markdown; charset=UTF-8; variant=GFM
url = https://github.com/AFM-SPM/TopoStats
project_urls =
  Bug Tracker = https://github.com/AFM-SPM/TopoStats/issues
  Documentation = https://AFM-SPM.github.io/TopoStats
author = TopoStats Team
author_email = topostats@sheffield.ac.uk
license = GNU Lesser GPLv3
classifiers =
  Programming Language :: Python :: 3
  Programming Language :: Python :: 3.8
  Programming Language :: Python :: 3.9
  Programming Language :: Python :: 3.10
#+END_SRC

*** Options

The ~options~ section defines the minimum version of Python and the packages that it depends on. The directive ~package
= find:~ tells the tools that use this configuration file (e.g. ~build~ for building packages) to look for directories
that contain ~__init__.py~ files which indicate the directory is a module (or sub-module) and should be included in the
package.

#+CAPTION: Sample ~options~ section of ~setup.cfg~ from [[https://github.com/AFM-SPM/TopoStats/blob/main/setup.cfg][TopoStats]].
#+BEGIN_SRC conf :eval no
[options]
python_requires = >=3.8

zip_safe = False

install_requires =
  igor
  matplotlib
  numpy
  pandas
  pySPM
  pyyaml
  ruamel.yaml
  schema
  scikit-image==0.19.2
  scipy
  seaborn
  tifffile
  tqdm


packages = find:

#+END_SRC

*** Extras Requirements

These are additional packages that are /not/ installed by default when a package is ~pip install~ because they are not
directly required for the package to run/function (i.e. they are not "runtime dependencies"). They can be divided into
sub-groups such as dependencies that are required for ~tests~, building ~docs~ or ~dev~ (development).

#+CAPTION: Sample ~options.extras_require~ section of ~setup.cfg~ from [[https://github.com/AFM-SPM/TopoStats/blob/main/setup.cfg][TopoStats]].
#+BEGIN_SRC conf :eval no
[options.extras_require]
tests =
  py
  pytest
  pytest-cov
  pytest-mpl
  pytest-regtest

docs =
  Sphinx
  sphinx_rtd_theme
  numpydoc
  myst_parser
  pydata_sphinx_theme
  sphinx_markdown_tables
  sphinxcontrib-mermaid
  sphinxcontrib-napoleon
  sphinx-autodoc-typehints

dev =
  black
  pre-commit
  pylint
  flake8

pypi =
  build
  wheel

#+END_SRC

*** Packages Find

Because packages are detected using the ~find:~ directive (see above) you may want to exclude certain directories such
as ~tests/~

#+CAPTION: Sample ~options.packages.find~ section of ~setup.cfg~ from [[https://github.com/AFM-SPM/TopoStats/blob/main/setup.cfg][TopoStats]].
#+BEGIN_SRC conf :eval no
[options.packages.find]
exclude = tests*

#+END_SRC

*** Coverage

This section is used to define the metrics for code coverage by tests. The example below excludes certain directories
and files (e.g. ~tests/~).

#+CAPTION: Sample ~options.coverage:run~ section of ~setup.cfg~ from [[https://github.com/AFM-SPM/TopoStats/blob/main/setup.cfg][TopoStats]].
#+BEGIN_SRC conf :eval no
[coverage:run]
omit =
  *conftest.py
  *tests*
  **/__init__*
#+END_SRC


*** Flake8

[[https://flake8.pycqa.org/en/latest/][Flake8]] is a [[id:55581960-395e-443c-bd5d-bc00c496b6ae][Linter]]
#+CAPTION: Sample ~options.extras_require~ section of ~setup.cfg~ from [[https://github.com/AFM-SPM/TopoStats/blob/main/setup.cfg][TopoStats]].
#+BEGIN_SRC conf :eval no
[flake8]
max_line_length=120
docstring-convention=numpy
exclude =
    .git,
    __pycache__,
    docs/conf.py,
    build,
    dist,
    pygwytracing.py,
    topostats/plotting.py,
    topostats/tracing/tracingfuncs.py,
    topostats/tracing/dnatracing.py,
    topostats/tracing/tracing_dna.py,
    tests/tracing/test_dnatracing.py,
extend-ignore =
    E501,
    T201
#+END_SRC

*** Yapf

#+CAPTION: Sample ~options.extras_require~ section of ~setup.cfg~ from [[https://github.com/AFM-SPM/TopoStats/blob/main/setup.cfg][TopoStats]].
#+BEGIN_SRC conf :eval no
[yapf]
based_on_style = pep8
column_limit = 120


#+END_SRC

*** Package Data

Sometimes you want to include more than ~.py~ files in your package, for example [[id:fac7a695-9bdf-4a79-9ec3-9945e9a0cba4][yaml]] files that contain configuration
options or [[id:950174e1-c936-463a-b4a2-702ca516d95e][json]] files with data. This can be achieved by adding an ~options.package_data~ section to your file. This can
be done across all package directories if ~* =~ is used.

To load the files of a package in your code you should use the [[https://docs.python.org/3.8/library/importlib.html][~importlib.resources~ module]]

Specific files can be included and excluded on a per package basis see [[https://jwodder.github.io/kbits/posts/pypkg-data/][examples]] and the [[https://setuptools.pypa.io/en/latest/userguide/datafiles.html][official documentation]].

#+CAPTION: Sample ~options.extras_require~ section of ~setup.cfg~ from [[https://github.com/AFM-SPM/TopoStats/blob/main/setup.cfg][TopoStats]].
#+BEGIN_SRC conf :eval no
[options.package_data]
 * = *.yaml
#+END_SRC

Alternatively it can be done on a per-directory basis if you have more than one module within your package.

#+CAPTION: Sample ~options.extras_require~ section of ~setup.cfg~ with per module options.
#+BEGIN_SRC conf :eval no
[options.package_data]
module1 = *.yaml
module2 = *.json
  *.csv
#+END_SRC

A useful thread on StackOverflow is [[https://stackoverflow.com/questions/6028000/how-to-read-a-static-file-from-inside-a-python-package][here]] (most useful answers I found were [[https://stackoverflow.com/a/58941536][this]] which includes a link to an [[https://github.com/wimglenn/resources-example][example
repository]] comparing the different approaches and [[https://stackoverflow.com/a/51724506][this exposition of pkgutil]]). You can load a YAML file with the
following which loads the file ~topostats/default_config.yaml~

#+CAPTION: Loading a YAML file from Package Data.
#+BEGIN_SRC python :eval no
import importlib.resources as pkg_resources
default_config = pkg_resources.open_text(__package__, "default_config.yaml")
config = yaml.safe_load(default_config.read())
#+END_SRC


*** Entry Points

It can be useful to provide an entry point to your package so that users can simply type a single command after
installing the package (typically under a virtual environment) to be able to run it from the command line. Typically you
would want to include a Command Line Interface that leverages [[id:5f7b632b-bb5b-48dd-b389-d8fcef406a19][Argparse]] to provide command line arguments. An exposition
of this approach can be read [[https://amir.rachum.com/blog/2017/07/28/python-entry-points/][here]] and the documentation on how to do this with setuptools is [[https://setuptools.pypa.io/en/latest/userguide/entry_point.html][here]]. Add something similar
to the following to your ~setup.cfg~

#+CAPTION: Sample ~options.extras_require~ section of ~setup.cfg~ from [[https://github.com/AFM-SPM/TopoStats/blob/main/setup.cfg][TopoStats]].
#+BEGIN_SRC conf :eval no
[options.entry_points]
console_scripts =
  run_topostats = topostats.run_topostats:main
#+END_SRC

*** Full Config

To see the full config please refer to  [[https://github.com/AFM-SPM/TopoStats/blob/main/setup.cfg][TopoStats]].

* Building your Package

** Generate Distribution Archive

In your package directory you can create a distribution of your package with the latest versions of ~setuptools~ and ~wheel~. To do
this in your virtual environment run the following. The documentation for how to do this is at [[https://setuptools.pypa.io/en/latest/setuptools.html][Building and Distributing
Packages with Setuptools]].

You should as mentioned above have the following in ~pyproject.toml~

#+begin_src :eval no
  [build-system]
  requires = [
    "setuptools >= 65.6.3",
    "wheel",
  ]
  build-backend = "setuptools.build_meta"
#+end_src

The package can now be built locally with...

#+begin_src bash :eval no
  python -m pip install --upgrade setuptools wheel
  python -m build
#+end_src

...and the resulting package will be generated in the ~dist/~ directory.

* Versioning

Typically the version is defined in the ~__version__~ value in the top-level ~__init__.py~ or as a value in ~[metadata]~
of either ~setup.cfg~ or ~pyproject.toml~ but this has some downsides in that you have to remember to update the string
manually when you are ready for a release and it doesn't tie in with using tags in Git to tag versions of your commits.

It is worth taking a moment to read and understand about [[https://semver.org/][Semantic Versioning]] which you are likely to use in versioning
your software.

** Versioneer
:PROPERTIES:
:CUSTOM_ID: versioneer
:END:

Enter [[https://github.com/python-versioneer/python-versioneer][versioneer]] which specifically sets out to handle this very problem.

#+BEGIN_QUOTE
This is a tool for managing a recorded version number in distutils/setuptools-based python projects. The goal is to
remove the tedious and error-prone "update the embedded version string" step from your release process. Making a new
release should be as easy as recording a new tag in your version-control system, and maybe making new tarballs.
#+END_QUOTE

The [[https://github.com/python-versioneer/python-versioneer/blob/master/INSTALL.md][installation instructions]] are concise and clear and should be easy to follow. Configuration is through a section in
~setup.cfg~ and typically the required style is ~pep440~ but it is worth being aware that ~versioneer~ produces versions
that indicates if you're branch ~HEAD~ is ahead of the last ~git tag~ that was applied and that these are not compliant
with [[https://peps.python.org/pep-0440/][PEP440]]. The side effect of this is that you will not be able to upload your package to [[https://pypi.org][PyPI]] either manually or via
a GitHub Action (more on this below). If you want to force PEP40 compliance then you should use ~style = pep440-pre~
which whilst indicating information about how far ahead of the last tag the current commit is still produces valid
PEP440 versions.

*** Configure ~setup.cfg~/~pyproject.toml~

You need to add configuration to ~setup.cfg~ or ~pyproject.toml~. The ~versionfile_source~ /~versionfile_build~
directories are typically the package name if you have followed the structure suggested in the [previous
article](python-packages-3), but see the [[https://github.com/python-versioneer/python-versioneer/blob/master/INSTALL.md][versioneer documentation]] for further details. If your [[https://git-scm.com/book/en/v2/Git-Basics-Tagging][git tags]] contain a prefix
then you should include it. If your package unpacks to a specific directory then include it under ~parentdir_prefix~.

#+begin_src
[versioneer]
VCS = git
style = pep440
versionfile_source = <package_name>/_version.py
versionfile_build = <package_name>/_version.py
tag_prefix = v
parentdir_prefix =
#+end_src

#+begin_src
[tool.versioneer]
VCS = "git"
style = "pep440"
versionfile_source = "<package_name>/_version.py"
versionfile_build = "<package_name>/_version.py"
tag_prefix = ""
parentdir_prefix = ""
#+end_src

*** Install

You can now install ~versioneer~ into your package, there are two options ~--vendor~ or ~--no-vendor~ to choose
between. Typically I would opt for ~--vendor~ as the non-vendored mode is experimental and requires additional
configuration options in ~pyproject.toml~ (see [[https://github.com/python-versioneer/python-versioneer/blob/master/INSTALL.md][versioneer documentation]] for further details).


#+begin_src bash :eval no
versioneer install --vendor
#+end_src

This will install files and stage them automatically, remember to stage your changes to ~setup.cfg~ / ~pyproject.toml~
before committing.

*** Build

When it comes to building I found that the current version of [[https://pypa-build.readthedocs.io/en/latest/][build]] (0.8.0 as of writing) by default creates a virtual
environment to build the package under and this resulted in an error about ~versioneer~ not being installed (see [[https://github.com/python-versioneer/python-versioneer/issues/192][related
issue #192]], although I was using the default ~style = pep440~). My solution was to try using the ~--no-isolation~ (~-n~)
flag to build so that a virtual environment was not used.

#+BEGIN_SRC bash :eval no
  python -m build --no-isolation
  * Getting dependencies for sdist...

#+END_SRC

You should find your package builds and the resulting ~.tar.gz~ and ~.whl~ files include the version calculated by
~versioneer~ and that it will be based on the most recent tag. If your branch is ahead of the last tag then it will
include information on how far ahead it is.

*** Excluding ~<package>/_version.py~

You may wish to exclude the ~<package>/_version.py~ from some of your linting if for example you are using
[[https://ns-rse.github.io/posts/pre-commit][pre-commit]].  At the command line you can exclude a file from being included in ~flake8~ analyses with
~--exclude=<patterns>~ and so at the command line you would.

#+CAPTION: ~flake8~ excluding ~_version.py~
#+BEGIN_SRC bash :eval no
flake8 --exclude=<package>/_version.py
#+END_SRC

If you are using ~pre-commit~ then you can exclude the ~_version.py~ file from different linting processes by modifying
the appropriate configuration files.

#+CAPTION: ~setup.cfg~ excluding ~_version.py~ from ~flake8~
#+BEGIN_SRC conf :eval no
[flake8]
max_line_length=120
docstring-convention=numpy
exclude =
    .git,
    __pycache__,
    docs/conf.py,
    build,
    dist,
    _version.py
#+END_SRC

#+CAPTION: ~.pylintrc~ excluding ~_version.py~ from ~pylint~
#+BEGIN_SRC conf :eval no
ignore=CVS,
       _version.py
#+END_SRC

** Step-by-step

1. ~pip install versioneer~
2. Modify ~pyproject.toml~ or ~setup.cfg~ (I use the later). It is /vital/ that the ~tag_prefix~ is correct.
   #+BEGIN_SRC python :eval no
   [versioneer]
   VCS = git
   style = pep440
   versionfile_source = clarity/_version.py
   versionfile_build = clarity/_version.py
   tag_prefix = v
   parentdir_prefix =
   #+END_SRC
3. If using non-vendored mode further modify ~pyproject.toml~
4. Add ~import versioneer~ and additional lines to obtain version to ~setup.py~
   #+BEGIN_SRC python :eval no
     """Package setup"""
     from setuptools import setup
     import versioneer

     setup(
         version=versioneer.get_version(),
         cmdclass=versioneer.get_cmdclass(),
     )
   #+END_SRC
5. Run ~versioneer install --[no-]vendor~ (I have used ~--no-vendor~ so far).
6. Add ~versioneer~ to the ~[pypi]~ requirements section of ~setup.cfg~
   #+BEGIN_SRC python :eval no
   [options.extras_require]
   pypi =
     build
     versioneer
   #+END_SRC
7. ~pip install .[pypi]~
8. Add the ~pypi.yaml~ to ~\~/.github/workflows/~ directory.

9. Add new repository secrets for [[https://pypi.org/][PYPI_API_TOKEN]] and [[https://test.pypi.org][TEST_PYPI_API_TOKEN]] under /Settings > Secrets > Actions/ you have
   to generate the tokens on both PyPI and Test PyPI.


* Publishing to [[https://pypi.org][PyPI]]

Before pushing the package to the main PyPi server it is prudent to test things out on  [[https://test.pypi.org/][TestPyPI]] first. You must first
generate an API Token from your account settings page. It needs a name and the scope should be `Entire account (all
projects)`. This token will be shown once so do *not* navigate away from the page until you have copied it.


You use [[https://twine.readthedocs.io/en/latest/][twine]] to upload the package and should create a ~.pypirc~ file in the root of the packages directory that
contains your API key and the username ~__token__~

#+begin_src conf :eval no
  [testpypi]
    username = __token__
    password = pypi-dfkjh9384hdszfkjnkjahkjfhd3YAJKSHE0089asdf0lkjsjJLLS_-0942358JKHDKjhkljna39o854yurlaoisdvnzli8yw459872jkhlkjsdfkjhdfJZZZZZF
#+end_src

Once this is in place you are ready to use ~twine~ to upload the package using the configuration file you have just
created.

#+begin_src bash :eval no
  twine upload --config-file ./.pypirc --repository testpypi dist/*
#+end_src

** Testing Download

After having uploaded your package to the TestPyPI server you should create a clean virtual environment and try
installing the package from where you have just uploaded it. You can do this using ~pip~ and the ~--index-url~ and
~--extra-index-url~, the former installs your package from TestPyPI, the later installs dependencies from PyPI.

#+begin_src bash :eval no
  pip install --index-url https://test.pypi.org/simple/ --extra-index-url https://pypi.org/simple/ your-package
#+end_src

Once installed you can try running the code, scripts or notebooks associated with the package as you would normally.

** Repeat for PyPI

Once you are happy this is working you can repeat the process on the main [[https://pypi.org][PyPI]] server. You can add the token that you
generate to ~/.pypirc~ under a separate heading.

#+begin_src conf :eval no
  [testpypi]
    username = __token__
    password = pypi-dfkjh9384hdszfkjnkjahkjfhd3YAJKSHE0089asdf0lkjsjJLLS_-0942358JKHDKjhkljna39o854yurlaoisdvnzli8yw459872jkhlkjsdfkjhdfJZZZZZF
  [pypi]
    username = __token__
    password = pypi-dfkjh9384hdszfkjnkjahkjfhd3YAJKSHE0089asdf0lkjsjJLLS_-0942358JKHDKjhkljna39o854yurlaoisdvnzli8yw459872jkhlkjsdfkjhdfJZZZZZF
#+end_src


** GitHub Action

Manually uploading is somewhat time consuming and tedious. Fortunately though with versioneer in place and tokens
generated we can automate the process of building and uploading packages to PyPI using the GitHub Action
[[https://github.com/pypa/gh-action-pypi-publish][gh-action-pypi-publish]] (read more about [[id:e19b6eb6-46b2-440a-ba35-be29feb33407][GitHub Actions]]). You will have already generated [[https://pypi.org/help/#apitoken][generate a PYPI token]] (and
similarly one for [[https://test.pypi.org][test PyPI]]) and these can stored on the projects GitHub account under /Settings > Secrets > Actions/
with the names ~PYPI_API_TOKEN~ and ~TEST_PYPI_API_TOKEN~ respectively.  You can then include the following GitHub
Action under ~.github/workflow/pypi.yaml~.

#+BEGIN_SRC yaml :eval no
name: Publish package to PyPi

on:
  push:
    tags:
      - v*
jobs:
  build-release:
    runs-on: ubuntu-latest
    name: Publish package to PyPi
    steps:
      - uses: actions/checkout@v3
        with:
          fetch-depth: 0
      - name: Setup Python
        uses: actions/setup-python@v4.3.0
        with:
          python-version: 3.9
      - name: Installing the package
        run: |
          pip3 install versioneer
          pip3 install .
          pip3 install .[pypi]
      - name: Build package
        run: |
          python -m build --no-isolation
      - name: Publish package to PyPI
        uses: pypa/gh-action-pypi-publish@release/v1
        with:
          user: __token__
          password: ${{ secrets.PYPI_API_TOKEN }}
#+END_SRC


** Releasing via GitHub
:PROPERTIES:
:mtime:    20230103103311
:ctime:    20230103103311
:END:

With [[#versioneer][versioneer]] in place and a [[id:5e1f167e-5c0c-4206-b2ac-6694e08524d8][GitHub Action]] setup and configured it is now possible to make a release to PyPI via
GitHub Releases.

1) Go to the Releases page (its linked from the right-hand side of the front-page).
2) Draft a New release.
3) Create a new tag using semantic versioning and select "Create new tag v#.#.# on publish".
4) Click the "Generate Release Notes" button, this adds all the titles for all Pull Requests, I'll often remove all
   these but leave the link to the ~ChangeLog~ that is generated for the release.
5) Write your release notes.
6) Select "Set as latest release".
7) Select "Create a discussion for this releases" and select "Announcements".
8) Click on "Publish Release".

* PDM
:PROPERTIES:
:ID:       37748065-f956-4d0c-9301-c4d51439b1b4
:mtime:    20221228113913 20230103103309
:ctime:    20221228113913
:END:


[[https://pdm.fming.dev/latest/][PDM]] (Python package and Dependency Manager) handles all stages of setting up and creating a package and managing its
dependencies. In essence its a tool for interactively generating the configuration files described above.


* Poetry
:PROPERTIES:
:ID:       8aed2c14-86e7-4b0e-bfe6-e783831bfca2
:END:

[[https://python-poetry.org/][Poetry]] is another package for managing packaging and dependencies.

* Links

+ [[https://setuptools.pypa.io/en/latest/userguide/index.html][PyPA : Building and Distributing Packages with Setuptools]]
+ [[https://packaging.python.org/en/latest/specifications/][PyPA : Specifications]]
+ [[https://packaging.python.org/en/latest/tutorials/packaging-projects/][Packaging Python Projects]]
+ [[https://github.com/wimglenn/resources-example][Packaging Data files in a Python Distribution]]
+ [[https://pdm.fming.dev/latest/][PDM - Python package and Dependency Manager]]
+ [[https://blog.ganssle.io/articles/2021/10/setup-py-deprecated.html][Why you shouldn't invoke setup.py directly]]
