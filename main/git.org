:PROPERTIES:
:ID:       3c905838-8de4-4bb6-9171-98c1332456be
:mtime:    20230103150851 20230103103309 20230102213516 20230103103309
:ctime:    20230102213516 20230103103309
:END:
#+TITLE: Git
#+DATE: <2022-05-24 Tue 22:07>
#+FILETAGS: :git:programming:documentation:version control:

[[https://git-scm.com][Git]] is the defacto standard for version control of code (and more) these days. Whether you write code in [[id:5b5d1562-ecb4-4199-b530-e7993723e112][Python]], [[id:de9a18a7-b4ef-4a9f-ac99-68f3c76488e5][R]],
scripts for [[id:ab2f5dfb-e355-4dbb-8ca0-12845b82e38a][Literate Programming]], Go, Rust, C++, Java, [[id:9c6257dc-cbef-4291-8369-b3dc6c173cf2][Bash]] or want to keep critical files such as your dotfiles,
~/etc/~, or GPG encrypted passwords backed up you should consider using Git (or some other version control system, but
Git is the most popular for now).

It can be daunting facing yet another new area to tackle as you are only just getting to grips with a programming
language having to learn a bunch of unfamiliar concepts that seem of little value, I know I've been there, but it really
does pay dividends to invest time learning how to use Git. You will benefit from having your code backed up off-site,
the ability to work across multiple computers on the same code base, collaborate with others on code development, know
what changes have been made at which point in the history of the code development and in turn benefit from being able to
revert changes that are not required.

If you use [[id:754f25a5-3429-4504-8a17-4efea1568eba][Emacs]] then you should definitely be using [[id:220d7ba9-d30e-4149-a25b-03796e098b0d][Magit]].

* Concepts
:PROPERTIES:
:ID:       292f6e62-a56e-4e71-9801-05c96b950af5
:mtime:    20230102213516 20230103103309
:ctime:    20230102213516
:END:

A repository is placed under version control when you ~git init~ within in but before doing so you need to set some
variables such as the ~user~ and ~email~. These can be done on a global scale which will apply across all repositories
you create or a local, per-repository basis (local settings in a repository over-ride global so they don't conflict).

#+CAPTION: Git Workflow by [[https://nikkiandchris.io][nikkiandchris.io]]
[[./img/git/git_pull_push.jpg]]

* Setup
:PROPERTIES:
:ID:       75050201-e41c-40a4-bd65-cd1c0592951c
:END:

** Global Configuration

First thing to do is setup Git with your name and email address and a
few other common default settings.

#+begin_src sh
git config user.name 'My Username'
git config user.email 'my@email.org'
git config --global push.default upstream # Syncs pull/push to the same branch (https://stackoverflow.com/a/42642628/1444043)
#+end_src

** Local Configuration

Each repository is configured via the file ~./.git/config~. Sometimes though you have multiple Git accounts
(e.g. personal and work) and you can use a neat [[https://blog.gitguardian.com/8-easy-steps-to-set-up-multiple-git-accounts/][trick]] to keep your configurations separate if you keep such work in
separate directories (e.g. ~~/work/~ and ~~/personal~). Define a separate ~~/work/.gitconfig-work~ and
~~/personal/.gitconfig-personal~  such as...

#+begin_example
[user]
email = your.personal@email.com
name = Your Name

[github]
user = "personal_github_username"

[core]
sshCommand = "ssh -i ~/.ssh/<personal_ssh_key>"
#+end_example

#+begin_example
[user]
email = your.work@email.com
name = Your Name

[github]
user = "work_github_username"

[core]
sshCommand = "ssh -i ~/.ssh/<work_ssh_key>"
#+end_example

In your global ~~/.gitconfig~ you then set the following.

#+begin_example
[includeIf “gitdir:~/personal/”] # include for all .git projects under personnal/
path = ~/personal/.gitconfig-personal

[includeIf “gitdir:~/work/”]
path = ~/work/.gitconfig-work
#+end_example

I've written more on using per-repository SSH keys at [[https://ns-rse.github.io/posts/git-ssh/][Git: Custom SSH credentials for git repositories]].
** .gitignore

You can tell Git to automatically ignore certain files by adding file blobs to the file ~.gitignore~ in the root of your
repositories directory (i.e. the highest level). This is useful as you can exclude temporary files that your test editor
might create (e.g. Emacs leaves behind ~*~~ files) and if you're working with patient data then its quite likely that
this shouldn't be shared in a public repository such as GitHub. The [[https://github.com/github/gitignore][github/gitignore]] repository has a number of
skeleton/example files for different languages including [[https://github.com/github/gitignore/blob/master/R.gitignore][R]], I modify this to include all ~*.RData~ files to exclude any
and all R Data objects and also Emacs temporary files ~*~~. There is also [[https://www.gitignore.io/][gitignore.io]] which generates configs
automatically.

** Shell Autocompletion

Git (>2.37.3 at least, perhaps before) ships with the file that automates git completion. Under Gentoo this installs at
~/usr/share/bash-completion/completions/git~ and it includes instructions on how to use it.

* Forges
:PROPERTIES:
:CUSTOM_ID: git-forge
:mtime:    20230102213516
:ctime:    20230102213516
:END:

Forges are places where Git repositories are hosted online for collaborative work. If public then others can view, fork
(make a copy online), clone (make a local copy) and then change the code themselves and if its useful submit a Pull
Request to have their changes incorporated into the original body of code for a project. Read more about each Forge at
the linked pages.

| Forge    | Description                                                                                                                      |
|----------+----------------------------------------------------------------------------------------------------------------------------------|
| [[id:52b4db29-ba21-4a8a-9b83-6e9a8dc02f41][GitHub]]   | Perhaps the largest and most widely used forge. Purchased my Micro$oft a few years ago.                                          |
| [[id:7cbd61f2-d6a5-4e67-af72-2a13a5e86faa][GitLab]]   | Comparable services with strong CI/CD functionality. Its also a free, open source piece of software so you can host it yourself. |
| [[https://xethub.com/][XetHub]]   | /A collaboration platform for accessing, exploring and iterating on large-scale repositories, backed by the power of Git./       |
| [[https://codeberg.org/][Codeberg]] | /Codeberg is a collaboration platform and Git hosting for Free and Open Source Software, content and projects./                  |
| [[https://gitea.io][Gitea]]    | A self-hosted Git Forge                                                                                                          |
| [[https://forgejo.org/][Forgejo]]  | A fork of                                                                                                                        |

* Usage
:PROPERTIES:
:ID:       2e8feb62-b0b0-43d9-9da3-bfba3c9af848
:END:

** Initialise a repository

How you initialise a repository depends on whether you are doing it locally first or cloning a repository from a
[[#git-forge]]. If you bring a directory under git version control before setting up an online repository you can always
configure the remote (~origin~) afterwards.

*** Cloning a Remote Repository

Cloning a remote repository is straight-forward. On the front page of all forges (GitHub, GitLab, Codeberg etc.) is a
button above the listing of files to **Clone**. There are two methods of cloning, one uses ~https~ the other ~ssh~. To
use the later you will have had to add your SSH credentials to your user account on that forge.

#+CAPTION: Clonging a Git repository
#+NAME: git-clone
#+begin_example sh
  git clone
#+end_example

*** Locally

It is straight-forward to initialise a directory to be under git version control simply...


#+CAPTION: Initialising a local repository to bring it under Git version contorl.
#+NAME: git-local-init
#+begin_example sh
  git init
#+end_example

If you then want to bring this under version control for an ~origin~ you create at a Forge you can do so with...

#+begin_example sh
git remote add origin git@work.github.com:work/new-project.git
git push -u origin master
#+end_example

** Adding Files

#+CAPTION: Adding files within a git repository
#+NAME: git-add
#+begin_example sh
  git add file1.py tests/file2.py
#+end_example

** Ignoring Files

You can tell Git to automatically ignore certain files by adding file blobs to the file ~.gitignore~ in the root of your
repositories directory (i.e. the highest level). This is useful as you can exclude temporary files that your test editor
might create (e.g. Emacs leaves behind ~*~~ files) and if you're working with patient data then its quite likely that
this shouldn't be shared in a public repository such as GitHub. The [[https://github.com/github/gitignore][github/gitignore]] repository has a number of
skeleton/example files for different languages including [[https://github.com/github/gitignore/blob/master/R.gitignore][R]], I modify this to include all ~*.RData~ files to exclude any
and all R Data objects and also Emacs temporary files ~*~~. There is also [[https://www.gitignore.io/][gitignore.io]] which generates configs
automatically.

#+begin_example sh
# History files
.Rhistory
.Rapp.history

# All Data files
*.RData

# Example code in package build process
*-Ex.R

# RStudio files
.Rproj.user/

# Emacs tmp files
*~

# produced vignettes
vignettes/*.html
vignettes/*.pdf

# OAuth2 token, see https://github.com/hadley/httr/releases/tag/v0.3
.httr-oauth
#+end_example

** Moving Files
You might rename a file and want delete the original, how to do this in Git? The solution is to ~mv~ your file just as
you would for a normal.
file.

#+begin_example sh
git mv file1.txt file2.txt
git commit -m "Renaming file1.txt > file2.txt"
git push
#+end_example

** Deleting Files
To remove a file complete from a repository *and* delete it locally then use ~rm~.

#+begin_example sh
git rm file1.txt
git commit -m "remove file1.txt"
git push -u origin master
#+end_example

** Removing Files
Sometimes you will want to remove a file from a Git repository but not delete it, to do this use the ~rm --cached~
option.

#+begin_example sh
# Remove a file
git rm --cached file.txt
# Remove a directory
git rm --cached -r directory
#+end_example

** Making a commit

Typically a commit message should complete the sentence /This commit.../ and be succinct and informative. You can always
add additional information to commits but the title should be short /and/ informative.

#+CAPTION: Git commit with a message
#+NAME: git-commit
#+begin_example sh
  git commit -m "Adding first files to the repository"
#+end_example

** Pushing and Pulling



*** Fetch v Pull

Whether you work on a project collaboratively or simply use GitHub/GitLab to keep personal repositories in sync between
systems you will at some point have to use ~git pull~ to get your changes onto your local computer. But what is ~git
fetch~ and how does it differ from ~git pull~? The simplest answer to this is provided by this excellent cartoon from
[[https://allisonhorst.com/git-github][Allison Horst]].

#+CAPTION: ~git fetch~ v ~git pull~ by [[https://allisonhorst.com/git-github][Allison Horst]]
#+NAME: fig:git-fetch-v-git-pull

[[./img/git/git_fetch_v_pull.png]]

*** Forcing pulls
:PROPERTIES:
:CUSTOM_ID: forcing-pulls
:END:
Sometimes you want to manually force a pull, and whilst it might be
tempting to use =git pull -f= this is not the best approach, rather you
should [[https://stackoverflow.com/a/9589927/1444043][use fetch and
reset]].

#+CAPTION:
#+NAME:
#+begin_example sh
git fetch origin master
git reset --hard FETCH_HEAD
git clean -df
#+end_example

* Branches
The beauty of Git is that it allows multiple people to work on the same software project without interfering with each
others work.  This is done through [[https://git-scm.com/book/en/v2/Git-Branching-Basic-Branching-and-Merging][]branching and merging]].


On GitHub/GitLab/BitBucket you will find the option to make a branch of a repository, but its generally cleaner to make
branches on your local machine and then have them pushed and updated to your remote (`origin`).  Create a branch and
switch to it in one step using...


#+CAPTION:
#+NAME:
#+begin_example sh
git checkout -b new_branch
#+end_example

You can see what branches there are now locally and which you are currently on using...

#+CAPTION:
#+NAME:
#+begin_example sh
git branch --list
 * new_branch
  master
#+end_example

If you create a branch locally it will not exist on the remote ~origin~. How does the remote repository know/become
aware of this new branch? If you try to push a ~local~ branch that doesn't exist on ~orogin~ then ~git~ will helpfully
tell you how to push from your ~local~ branch to ~origin~ and create the branch there.

#+CAPTION:
#+NAME:
#+begin_example sh
  git push --set-upstream origin new_branch
#+end_example

 You can push and update all branches on the remote ~origin~ with...


#+CAPTION:
#+NAME:
#+begin_example sh
git push --all -u
#+end_example

** Branching from a specified branch
Sometimes you may be working on a problem with others simultaneously and wish to develop you work together /before/
merging to master. In such an instance you could create a ~development~ branch and push your work to this to ensure
changes you and your colleague make are consistent and work before you merge that to master.

#+CAPTION:
#+NAME:
#+begin_example sh
git branch --list
 development
 master
#+end_example

I want branch from ~development~ rather than ~master~ and so you...

#+CAPTION:
#+NAME:
#+begin_example sh
git checkout -b my_new_branch development
#+end_example

** Move Most Recent Commit to a New Branch
From [[https://stackoverflow.com/a/1628584/1444043][here]]...

#+CAPTION: Move most recent commit from existing branch to a new branch.
#+NAME:
#+begin_example sh
git branch a_new_branch     # This creates a new branch from the existing.
git reset --hard ad1290ai   # Remove the last commit from the current branch
git checkout a_new_branch   # Moves to the new branch which includes the last commit
#+end_example

** Tidying up Merged Branches

Lots of articles out there on [[https://railsware.com/blog/git-housekeeping-tutorial-clean-up-outdated-branches-in-local-and-remote-repositories/][Git housekeeping]] one simple thing to do is use...

#+CAPTION: Prune branches that have been merged on fetching.
#+begin_example sh
git fetch -p
#+end_example

...which will prune branches that have been merged on fetching.

** Keep up with ~main~

As you work on your feature branch development will likely be on-going in other branches which are merged into ~main~
when complete. To avoid headaches when you commit to submit a Pull Request for your completed feature you should
regularly merge main into your branch.

#+begin_example sh
  git pull origin main        # Pulls the latest changes from origin/main
  git merge main --squash     # Merge the changes into your feature branch and squash commits
#+end_example

This may result in merge conflicts that you'll have to resolve, as you are likely to continue working on your branch it
is worthwhile enabling the [[https://git-scm.com/docs/git-rerere][Reuse Recorded Resolution (~rerere~)]] option so that you do not have to resolve such conflicts
in the future (from [[https://samwize.com/2022/12/15/tips-to-resolve-merge-conflicts-for-long-lived-branches/][here]]).

#+begin_example sh
  git config --global rerere.enabled true
#+end_example

However, there is another option to merging  ~main~ onto your branch that may be preferable and that is [[id:57ba7f41-cf41-493c-bbf4-9d1e05a0602d][Git Rebase]]. The
main reason for using ~git rebase main~ over ~git merge main~ is the resolution of conflicts. When using ~git merge
main~ all conflicts have to be dealt with in one go, however with ~git rebase main~ each commit from the ~main~ branch
is merged with your branch in turn and requires any conflicts to be resolved before merging the next commit. This can
make resolving conflicts a lot easier.

** Trees instead of branches

One of the challenges of working on branches is that whilst its easy to switch between them if you have work in progress
you either need to ~git commit~ or ~git stash~ (and the ~git stash pop~ on returning to the branch) in order to
switch. An alternative model to this is to use [[id:ad99d902-5005-481e-95d2-e91ba0dcc859][Git Worktree]].

* Merge Conflicts
:PROPERTIES:
:ID:       eea4a7d2-76b0-4328-9eca-cad7b6e1ff41
:mtime:    20230102213516 20230103103309
:ctime:    20230102213516 20230103103309
:END:

Merge conflicts arise when you have edited a file and someone else has edited the same point in the same file and their
changes have been merged before your Pull Request was made/approved. Git, whilst smart, doesn't know what to do in such
situations and so defers to the humans, asking them to resolve the conflict.

** Anatomy

Git conflicts are clearly marked in files.

** Resolving


* Git Stash
:PROPERTIES:
:ID:       f5784a68-fc79-4151-8737-28e6e43445de
:END:


Sometimes if you've work in progress (WIP) you may end up stashing your changes when you ~git pull~ as you'll be
informed that doing so would over-write unsaved changes and you should either ~git commit~ or ~git stash~. This later
strategy of [[https://www.git-scm.com/docs/git-stash][stashing]] is useful when you are not ready to ~git commit~ as you intend on coming back to your work. Its
straight-forward to make a stash...

#+begin_example sh
  git stash
#+end_example

You can view the list of stashes, which are specific to the branches on which they were created with either of the
following (~show~ gives greater detail).

#+begin_example sh
  git stash list
  stash@{0}: WIP on master: 70de7ca youtube-dl configuration
  stash@{1}: WIP on master: 6a8cdb0 Updating gitconfig/authinfo and install.R
#+end_example

** Applying Stashed Changes

When you return to your Work In Progress on the branch you are working on you likely want to restore the last saved
stash or another stash in from the history. This is achieved using the ~pop~ directive. Without any arguments it applies
the last stash, but its possible to specify the stash you wish to restore.

#+begin_example sh
  git stash pop
  git stash pop 6a8cdb0
  git stash pop stash@{1}
#+end_example

** Discarding Stashes
:PROPERTIES:
:mtime:    20230103103311 20230102213516
:ctime:    20230102213516
:END:

Sometimes you may not want to keep your stashes, you can discard the most recent or a specific stash with ~drop
[<stash>]~ or you can clear all stashes with ~clear~

#+begin_example sh
  git stash drop
  git stash drop stash@{1}
  git stash clear
#+end_example

* Hooks
:PROPERTIES:
:ID:       3e2b5f0c-2dff-45c1-ae9c-7cc43b5c81ae
:mtime:    20230102213516
:ctime:    20230102213516
:END:

Hooks are incredibly useful (not just in Git, but in general and form the basis of many [[id:3b6a27c8-6ef9-4133-95b9-302d2e4dbea3][CI/CD]] pipelines), but they also
run locally on various Git actions such as ~pre-commit~, ~post-commit~, ~pre-push~ or ~pre-pull~. Hooks are simple [[id:9c6257dc-cbef-4291-8369-b3dc6c173cf2][Bash]]
scripts that reside in ~.git/hooks~ with specific filenames that indicate at which stage they are to be run. Typically
this directory will be populated with various examples for the different hooks that are available if you have created
your repository locally.



* Commit History
:PROPERTIES:
:ID:       612ae69f-f001-43cb-be32-fe5051e7368f
:END:

Git keeps a detailed history of commits that contain metadata and other useful information.

** Git Log

There are many options for viewing and formatting the log history.

*** Git Short Log

A simple way to get the list of contributors is to

#+begin_example sh
  git shortlog -s -n -e
#+end_example

It can also be used to summarise contributions by combining with come command [[id:9c6257dc-cbef-4291-8369-b3dc6c173cf2][command line utilities]]. The following
formats commits by date (~YYYY-MM~), ~sorts~ them and then counts the number of ~uniq~ observations (from [[https://github.blog/2022-12-12-highlights-from-git-2-39/][here]]).

#+begin_example sh
  $ git log v2.38.0.. --date='format:%Y-%m' --format='%cd' | sort | uniq -c
#+end_example

*** Aliases

It's useful to be aware of the options that are available to you for formatting your logs, but it can be cumbersome to
memorise them, particularly so when often your primary focus is on getting work done rather than becoming an expert in
the tools you use. To which end using [[id:c7d811f9-5e9f-43b9-9b0b-d647a399756c][Bash aliases]] to provide shortcuts to the formatting you want is invaluable. The
[[id:a1b78518-31e8-4fd3-a36f-d8f152832138][zsh]] shell comes with a bundle of aliases pre-configured, typically I just use ~glod~ which shows the graph in short
form, but you may find others to be more suited to your preferences, and if not you can always specify your own.

** Blame

[[https://www.git-scm.com/docs/git-blame][Git Blame]] shows who was responsible for changes to which lines of code, read more [[id:d8b70d14-06bd-46c5-97fc-5c8e4f2c3503][Git Blame]].

** Reset and Revert

Useful article [[https://www.datacamp.com/tutorial/git-reset-revert-tutorial][here]].

* Git Rebase

Git rebase is a powerful tool as it allows you to re-write history (i.e. the commit log). Read more at [[id:57ba7f41-cf41-493c-bbf4-9d1e05a0602d][Git Rebase]].


* IDE Integration

** Emacs Magit

If you use [[id:754f25a5-3429-4504-8a17-4efea1568eba][Emacs]] (and why wouldn't you?) then you should use [[https:magit.vc][Magit]] to manage your Git repositorclarity/evaluator/haspi/y and interactions with
forges such as GitHub and GitLab. It includes the ability to synchronise locally details of issues and pull requests
from the repositories forge (but this requires a little extra work that is well documented).

** RStudio

[[id:fbe4e0bc-038d-4aeb-aa48-e312f469678e][RStudio]] has support for Git and GitHub baked in.

** GitKraken
[[https://www.gitkraken.com/][GitKraken]] is dedicated to working with your Git repositories and interacting with forges. It has some basic IDE features
for editing your code but it is really focused on helping you work with Git.

* Data Version Control

It is often important to version control your data too, for more on this see [[id:2013cd50-f008-422a-ade1-b97d6bfc3a2a][Data Version Control]].
* Links
+ [[https://git-scm.com][Git]]
+ [[https:magit.vc][Magit]]
+ [[https://www.gitkraken.com/][GitKraken]]

** Tools

+ [[http://gitignore.io/][gitignore.io]]

** Learning Resources

+ [[http://blog.anvard.org/conversational-git/][Conversational Git]]
+ [[https://git-scm.com/book/en/v2][Pro Git]]
+ [[https://gitbetter.substack.com/archive?sort=new][Git Better]]
+ [[https://ohshitgit.com/][Oh Shit, Git!?!]]
+ [[https://ohmygit.org/][Oh My Git!]] - a game for learning Git.
+ [[https://onlywei.github.io/explain-git-with-d3/#clean][Explain Git with D3]]
+ [[https://learngitbranching.js.org/][Learn Git Branching]]
+ [[https://srse-git-github-zero2hero.netlify.app/][Git & GitHub through GitKraken Client - From Zero to Hero]]

** HowTos

*** Rebase

+ [[https://www.howtogeek.com/849210/git-rebase/][Git rebase: Everything You Need to Know]]
+ [[https://about.gitlab.com/blog/2022/11/08/rebase-in-real-life/][GitLab Blog | How to use Git rebase in real life]]
+ [[https://about.gitlab.com/blog/2022/10/06/take-advantage-of-git-rebase/][GitLab Blog | Take advantage of Git rebase]]

*** Misc

+ [[https://samwize.com/2022/12/15/tips-to-resolve-merge-conflicts-for-long-lived-branches/][How to resolve merge conflicts for long-lived branches | @samwize]]
+ [[https://csswizardry.com/2017/05/little-things-i-like-to-do-with-git/#praise-people][Little Things I Like to Do with Git – CSS Wizardry – Web Performance Optimisation]]
+ [[https://www.scmgalaxy.com/tutorials/git-commands-tutorials-and-example-git-reset-git-revert/][Git Reset and Revert Tutorial for Beginners]]

** Workflows

+ [[https://www.atlassian.com/git/tutorials/comparing-workflows][Atlassian : Comapring Workflows]]
+ [[https://www.atlassian.com/git/tutorials/comparing-workflows/feature-branch-workflow][Atlassian : Feature Branching]]
+ [[https://www.atlassian.com/git/tutorials/comparing-workflows/gitflow-workflow][Atlassian : Gitflow Workflow]]
+ [[https://www.atlassian.com/git/tutorials/comparing-workflows/forking-workflow][Atlassian : Forking Workflow]]
+ [[https://datasift.github.io/gitflow/IntroducingGitFlow.html][Introducing GitFlow]]

** Miscellaneous

+ [[https://arialdomartini.github.io/no-reason-to-squash][No Reason to Squash]]
+ [[https://blog.trunk.io/minimum-viable-git-for-trunk-based-development-81a5da7a77a7][Minimize Git for maximum value]]

** Related

+ [[https://github.com/dolthub/dolt][Dolt]] - Git for Data
+ [[https://dvc.org/][DVC]] - Data Version Control
+ [[https://xethub.com/][XetHub]] - Large file/data storage with version control

** Alternatives

+ [[https://www.monotone.ca/][Monotone]]
+ [[https://forgefed.org/][ForgeFed]]
