:PROPERTIES:
:ID:       a37b61ba-8699-4ee3-b407-38f256c186c4
:mtime:    20241221211157 20241221201119 20241221163742 20241221152122 20241221072719 20241211112128 20240630205259 20240204192058
:ctime:    20240204192058
:END:
#+TITLE: Jujutsu
#+FILETAGS:

[[https://martinvonz.github.io/jj/latest/][Jujutsu]] is a new [[id:668debfd-9cf7-4577-9ae8-b63fcf044bb8][Version Control System]] developed by Martin von Zweigbergk at Google, although it is not an official
Google product and is Open Source Software licensed under the Apache 2.0 license.

It has its own internal/native backend but also supports using [[id:3c905838-8de4-4bb6-9171-98c1332456be][Git]] in the background to undertake all tasks. As such it
can be used as a drop-in replacement for [[id:3c905838-8de4-4bb6-9171-98c1332456be][Git]].

A big difference from the familiar Git model is that the working copy is automatically committed. If you check out a
commit this introduces a new working-copy commit where changes are recorded (no more ~detached HEAD~ state!).

* Installation

** Gentoo

~jj~ is available in the [[id:83017000-6081-4787-83c3-5e1639684909][Gentoo Overlays]] ~guru~, onc

#+begin_src
eselect repository enable guru
eix-sync
emerge -av dev-vcs/jj
#+end_src

** NixOS

~jj~ is also available for [[id:69291a6b-c253-44bc-ad9d-8d899bb90529][NixOS]]. You can use [[id:c9eb0e6d-b152-487c-90d4-3786fcfd0889][flake]] or [[id:01336e19-dc8a-41ca-8534-6a790b39b1b6][HomeManager]], I opted for the former and added the following to
~/etc/nixos/flake.nix~. Just add the following to ~/etc/nixos/configuration.nix~ to install the most recent release
system wide.

#+begin_src
environment.systemPackages = with pkgs{
  ...
  jujutsu
  ...
};
#+end_src

Then either ~nixos-rebuild test~ to install and test the installation (you should now have ~jj~ in your command line)
and if happy ~nixos-rebuild switch~ to make the change permanent and available on the next boot.
** Shell Integration

There is integration with both [[id:9c6257dc-cbef-4291-8369-b3dc6c173cf2][Bash]] and [[id:a1b78518-31e8-4fd3-a36f-d8f152832138][ZSH]] as well as [[https://jj-vcs.github.io/jj/latest/install-and-setup/#command-line-completion][other shells]].

*** Bash

#+begin_src
source <(jj util completion bash)
#+end_src
*** ZSH

#+begin_src
autoload -U compinit
compinit
source <(jj util completion zsh)
#+end_src

** Initial Configuration

As with Git you need to add your ~user.name~ and ~user.email~ to the configuration.

#+begin_src
jj config set --user user.name "Your Name"
jj config set --user user.email "your@email.address"
#+end_src

We can check the configuration...

#+begin_src
$ jj config list
ui.editor = "/usr/bin/nano"
ui.pager = "less"
user.email = "nshephard@protonmail.com"
user.name = "Neil Shephard"
#+end_src

This looks ok but I found that ~/usr/bin/nano~ is /wrong/ for a NixOS system....

#+begin_src
which nano
/run/current-system-sw/bin/nano
#+end_src

..so updated that along with switch from ~less~ to ~most~

#+begin_src
jj config set --user ui.editor "/run/current-system/sw/bin/nano"
#+end_jj config set --user ui.pager "/run/current-system/sw/bin/most"
#+end_src

* Usage

I wanted to keep ~/etc/nixos~ under version control using ~jj~ and as advised in  [[https://steveklabnik.github.io/jujutsu-tutorial/introduction/introduction.html][Steve's Jujutsu Tutorial]] opted to use
the Git backend.

#+begin_src
cd /etc/nixos
jj git init
jj st
Working copy changes:
A agenix.nix
A audio.nix
A bluetooth.nix
A configuration.nix
A configuration.nix~
A flake.lock
A flake.nix
A flake.nix~
A hardware-configuration.nix
A home.nix
A home.nix~
A luks.nix
A secrets/secrets.nix
A secrets/slack-vpn.age
A xfce.nix
A xfce.nix~
Working copy : vpqtltus 35cc03d2 (no description set)
Parent commit: zzzzzzzz 00000000 (empty) (no description set)
#+end_src

First things first, I don't want to the temporary emacs files included. According to the [[https://jj-vcs.github.io/jj/latest/working-copy/#ignored-files][documentation]] there is no
~.jjignore~ yet so we use ~.gitignore~ instead listing our files and patterns there.

#+begin_src
*~
\#*
#+end_src

...but the files are already being tracked because they were present when the repository was initialised. We therefore
need to untrack them with...

#+begin_src
jj file untrack
#+end_src

This failed because ~~~ is used in the syntax for [[https://jj-vcs.github.io/jj/latest/filesets/][jj filesets]] which is a method of defining patterns of files. I tried a
few things but in the end couldn't suss it out in the five minutes so took the brute force option of ~rm -rf .jj~ and
initialising the repository anew. We can look at the status with ~jj st~ and it will use our configured pager (which
I've set to ~most~) to show the changes.

#+begin_src
jj st
Working copy changes:
A .gitignore
A agenix.nix
A audio.nix
A bluetooth.nix
A configuration.nix
A flake.lock
A flake.nix
A hardware-configuration.nix
A home.nix
A luks.nix
A secrets/secrets.nix
A secrets/slack-vpn.age
A xfce.nix
Working copy : nxzzlvzo 43e6338e (no description set)
Parent commit: zzzzzzzz 00000000 (empty) (no description set)
#+end_src

We can see the changes (i.e. all new files) are already noted as being under the working copy. We can also use ~jj
describe~ to look at the changes, if we use the ~-m "A message"~ flag and value we can add a message and it will replace
the ~no description set~ shown by ~jj st~.  With ~jj describe~ the information is opened up in an editor, and if a
message has already been set it will be shown at the top. Note that lines begining with ~JJ~ will be removed (i.e. they
are comment lines). On adding a message or changing it the commit ID changes, the change ID remains the same but the
commit ID changes over time allowing us to refer to individual commits rather than a whole change set.

#+begin_src
jj describe -m "Initial commit with jj :)"
Working copy now at: nxzzlvzo d2d192ec Initial commit with jj :)
Parent commit      : zzzzzzzz 00000000 (empty) (no description set)
#+end_src

** New commits

We're ready to make some changes, but unlike Git we can make our commit /first/ rather than after having made the
changes. We do this with ~jj new~

#+begin_src
jj new
Working copy now at: mkrknnyv d20e2368 (empty) (no description set)
Parent commit      : nxzzlvzo d2d192ec Initial commit with jj :)
#+end_src

We can now modify a file, in this case I tidied up ~/etc/nixos/configuration.nix~ and put all ~network.*~ options within
a ~network = {...};~ block and similar aggregated all ~nix.*~ options into a ~nix = {...};~ block.

#+begin_src
jj st
Working copy changes:
M configuration.nix
Working copy : mkrknnyv 31f1c759 (no description set)
Parent commit: nxzzlvzo d2d192ec Initial commit with jj :)
#+end_src

We can see the full commit history with ~jj log~ (no surprisese there!)

#+begin_src
@  mkrknnyv nshephard@protonmail.com 2024-12-21 16:20:53 31f1c759
│  (no description set)
○  nxzzlvzo nshephard@protonmail.com 2024-12-21 15:48:47 d2d192ec
│  Initial commit with jj :)
◆  zzzzzzzz root() 00000000
#+end_src

Its interesting to note that the bold/highlighting of the start of commit hashes gives you an indication of the unique
component of that hash.

It is important to note that there is no need to explicitly make a commit, the work done/changes are already part of the
current commit. When you are ready to start the next piece of work you ~jj new~ (optionally with ~-m "<message>"~) to
* Diffing

You can view differences with ~jj diff~ and it will show the differences between the current "~HEAD~" and the previous
commit. I use ~difftastic~ (see Configuration section below) so have colourized output.

#+begin_src
home.nix --- Nix
152 152       urldecode = "python3 -c 'import sys, urllib.parse as ul; print(ul.unquote_plus(sys.stdin.read()))'";
153 153       urlencode = "python3 -c 'import sys, urllib.parse as ul; print(ul.quote_plus(sys.stdin.read()))'";
154 154     };
... 155     # initExtra = ''
... 156     #   if command -v keychain > /dev/null 2>&1; then eval $(keychain --eval --nogui ${keyFilename} --quiet); fi
... 157     # '';
155 158   };
156 159
157 160   programs.emacs = {

configuration.nix --- 1/2 --- Nix
177   # Some programs need SUID wrappers, can be configured further or are      177   # Some programs need SUID wrappers, can be configured further or are
178   # started in user sessions.                                               178   # started in user sessions.
179   # programs.mtr.enable = true;                                             179   # programs.mtr.enable = true;
180   programs.gnupg.agent = {                                                  180   programs = {
...                                                                             181     gnupg.agent = {
181     enable = true;                                                          182       enable = true;
...                                                                             183       # enableSSHSupport = true;
...                                                                             184     };
182     enableSSHSupport = true;                                                185     ssh.startAgent = true;
183   };                                                                        186   };
184                                                                             187
185   # List services that you want to enable:                                  188   # List services that you want to enable:
186   services = {                                                              189   services = {

configuration.nix --- 2/2 --- Nix
210 213     fprintd = {
211 214       enable = true;
212 215     };
... 216     # yubikey
... 217     yubikey-agent = {
... 218       enable = true;
... 219     };
213 220   };
214 221   # Open ports in the firewall.
215 222   # networking.firewall.allowedTCPPorts = [ ... ];
#+end_src

If you want to look at differences between two specific commits you can use the ~--from~ and ~--to~ options (the former
likely being more useful than the later).

* Remotes

I wanted to back my work up remotely and have a few options the ubiquitous [[id:52b4db29-ba21-4a8a-9b83-6e9a8dc02f41][GitHub]], [[id:7cbd61f2-d6a5-4e67-af72-2a13a5e86faa][GitLab]], or my self-hosted [[id:736537b3-75e0-4c24-9156-364937e0e8a2][Forgejo]]. I
opted for the later which is hosted on the VPS I pay for with [[https://ovh.co.uk][OVH]].

#+begin_src
jj git remote add origin git@forgejo.nshephard.dev:nshephard/crow.git
#+end_src

* Bookmarks (aka branches)

These are mainly for compatibility with Git, ~jj~ actually prefers to use anonymous rather than named branches
(sometimes called a "branchless" workflow).

* Revisions and Revsets

* Configuration

You can edit the [[https://jj-vcs.github.io/jj/latest/config/][configuration]] either at the ~--user~ or ~--repo~ level with ~jj config edit --[user|repo]~ (to find the
path of the users configuration file use ~jj config path --user~, repository configuration is in
~.jj/repo/config.toml~). These are [[id:80ebb47c-7c3e-4aa4-93c4-bb15f0ee7a01][TOML]] files.

I enabled color and like the brilliant [[https://difftastic.wilfred.me.uk/][difftastic]] (see also my notes on [[id:70e4fdce-e4f0-4702-95cd-2a6ad2f1c5c0][Magit Diffing]])

#+begin_src
[user]
name = "Neil Shephard"
email = "nshephard@protonmail.com"

[ui]
editor = "/run/current-system/sw/bin/nano"
pager = "/run/current-system/sw/bin/most"
color = "always"
# Use Difftastic by default
diff.tool = ["difft", "--color=always", "$left", "$right"]
#+end_src

...there are a lot more configuration options available (see  [[https://jj-vcs.github.io/jj/latest/config/][configuration]] documentation for full details).

* Workflow

Two popular workflows are described in the [[https://steveklabnik.github.io/jujutsu-tutorial/real-world-workflows/][tutorial]], the [[https://steveklabnik.github.io/jujutsu-tutorial/real-world-workflows/the-squash-workflow.html][Squash Workflow]] and the [[https://steveklabnik.github.io/jujutsu-tutorial/real-world-workflows/the-edit-workflow.html][Edit Workflow]].

** Squash Workflow

This is kind of link ~git commit --amend~ where changes are added to the existing ~HEAD~ commit of the branch. The ~jj~
workflow has at it's head (denoted by ~@~ in the ~jj log~ output) the "unstaged" changes and ~jj squash~ adds them to
the previous commit, which is typically created /before/ making any changes with a description of the intended work (you
could do this with ~git commit -a --allow-empty -m "bug: I'm going to squash a bug!"~ ) and then repeatedly ~git commit
--amend~ as we complete the work. With ~jj~ squash workflow though it encourages making smaller more atomic commits and
reduces the amount of "/fixing an error/tpyo" commits by those averse to using ~--amend~. By default all files are
included but you can specify just those files you want to include by listing them.

Jujutsu also allows interactive selection of lines to edit via the ~-i~ flag. A terminal interface opens and it is
possible to select which lines to include prior to making the commit. After having selected all the changes simply hit
`c` to confirm them.

If you decide you don't want to keep the work you can ~jj abandon~ the work in progress and it reverts all changes. In
fact ~jj squash~ offers much of the functionality of ~git rebase -i~.

** Edit Workflow

Continuing from the previous example we make some more changes, but rather than using ~new~, because there is already an
empty change there as we squashed the existing changes into the previous commit leaving ~@~ empty, we use ~jj describe
-m "message"~ to add a message to the empty commit that we are /not/ going to squash. Now make the changes and when
ready to start a new piece of work you can use ~jj new -m ""~.

*** Editing older commits

In Git this can be done either by adding a ~git commit --fixup~ or using ~git rebase -i~ tp interactively squash
commits. In ~jj~ though we can use ~jj new -B @ -m "a new message"~ and what this does is add a new commit ~-B~efore the
~@~ commit (other references can be used if you want to modify a commit further back in the commit history). You get for
free a rebase of descendant commits, of course conflicts can arise but this command /will/ always complete without
resolving the conflicts (yet!).

The "~HEAD~" of the "branch" has been moved to this commit and changes can be made and saved (they're already included
as there is no staging in Jujutsu). When done you can return to the "~HEAD~" using ~jj edit <minimal_hash>~ or the
convenience shortcut ~jj next --edit~ which moves ~@~ to the "child" commit and allows editing.

You can edit earlier commits with ~jj edit @-~ for the previous commit or ~jj edit <commit>~

* IDE/Interfaces

Being an Emacs user I naturally wanted to use Jujutsu via Emacs and was hoping for a [[id:220d7ba9-d30e-4149-a25b-03796e098b0d][Magit]] equivalent. Being
considerably newer there isn't anything quite as powerful as Magit just yet but there is work in progress in the form of
[[https://git.sr.ht/~puercopop/jujutsushi][jujutsushi - A emacs interface to jujutsu]]

* Links

+ [[https://martinvonz.github.io/jj/latest/][Jujutsu Documentation]]
+ [[https://github.com/martinvonz/jj#command-line-completion][martinvonz/jj: A Git-compatible VCS that is both simple and powerful]]

** Tutorials

+ [[https://steveklabnik.github.io/jujutsu-tutorial/introduction/introduction.html][Steve's Jujutsu Tutorial]]

** IDE/Interfaces

+ [[https://git.sr.ht/~puercopop/jujutsushi][jujutsushi - A emacs interface to jujutsu]]
+
** Blogs

+ [[https://v5.chriskrycho.com/essays/jj-init/][jj init — Sympolymathesy, by Chris Krycho]]
+ [[https://reasonablypolymorphic.com/blog/jj-strategy/index.html][Jujutsu Strategies :: Reasonably Polymorphic]]
+ [[https://ofcr.se/jujutsu-merge-workflow][A Better Merge Workflow with Jujutsu | ofcrse by Benjamin Tan]]
+ [[https://tonyfinn.com/blog/jj/][Jujutsu (jj), a git compatible VCS - Tony Finn]]
